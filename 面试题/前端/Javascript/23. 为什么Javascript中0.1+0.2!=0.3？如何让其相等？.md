这是因为JavaScript采用IEEE 754双精度64位浮点数来表示数字。在该标准下，小数在转换为二进制时，很多十进制小数无法精确转换，只能得到近似值。

0.1和0.2在转换为二进制后是无限循环的，存储时只能取近似值。当0.1和0.2相加时，得到的二进制结果再转换回十进制，就和理论上的0.3存在微小的误差，所以`0.1 + 0.2` 并不严格等于0.3。 


在 JavaScript 里，由于浮点数精度问题致使 `0.1 + 0.2` 不等于 `0.3`，可以通过以下几种办法让它们在实际应用中“相等”：

### 1. 四舍五入
借助 `toFixed()` 方法对计算结果进行四舍五入，设定合适的小数位数，再进行比较。`toFixed()` 会把数字转换为字符串，所以比较前可能需要转回数字类型。

### 2. 设置误差范围（使用容差）
定义一个极小的误差范围（也叫容差），当两个数的差值小于这个误差范围时，就认为它们相等。在实际应用中，`Number.EPSILON` 经常被用作这个误差范围，它表示 JavaScript 中能够表示的最小正数。

### 3. 使用整数运算
把小数转换为整数进行运算，运算完成后再转换回小数。这样可以避免浮点数运算带来的精度问题。比如将小数乘以一个合适的倍数变成整数，计算结束后再除以相同的倍数。

### 4. 使用第三方库
像 `decimal.js`、`big.js` 这类库，它们能处理任意精度的十进制数，避免浮点数精度问题。你可以用这些库来进行精确的小数运算。 